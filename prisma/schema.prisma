generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url = env("POSTGRES_PRISMA_URL") // uses connection pooling
  directUrl = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
}

model Room {
  id           String      @default(cuid()) @id
  title        String
  created_at   DateTime    @default(now())
  updated_at   DateTime    @default(now())
  admin        User        @relation(fields: [admin_fk], references: [id]) // one to one
  admin_fk     String
  location     Location?   @relation(fields: [locationId], references: [id])
  locationId   String?
  participants Participant[]   // Define the many-to-many relationship
  cover        Cover?       @relation("RoomCover", fields: [coverId], references: [id])
  coverId      String?      @unique
  noteWidget   NoteWidget?  
}
 model Cover {
  id                  String      @default(cuid()) @id
  formattedUrl        String      
  cloudinaryPublicId  String      
  room                Room?       @relation("RoomCover")
}

model Location {
  id            String            @default(cuid()) @unique 
  latitude      Float
  longitude     Float
  country       String?
  city          String?
  state         String?
  rooms         Room[]

  @@id([latitude, longitude])
}


model Participant {
  id            String     @default(cuid()) @id
  user          User       @relation(fields: [user_id], references: [id])
  user_id       String
  room          Room       @relation(fields: [room_id], references: [id])
  room_id       String
  is_favourited Boolean
  created_at    DateTime  @default(now())
  visited_at    DateTime  @default(now())

  @@unique([user_id, room_id]) // Ensure each user is in a room only once
}


model User {
  id                  String      @default(cuid()) @id
  first_name          String
  last_name           String
  email               String      @unique
  email_verified_at   DateTime?
  created_at          DateTime    @default(now())
  updated_at          DateTime    @default(now())
  password            String 
  birthday            String 
  avatar              Avatar?     @relation("UserAvatar", fields: [avatarId], references: [id])
  avatarId            String?     @unique
  status              Status      @relation(fields: [status_fk], references: [id]) 
  status_fk           String
  rooms               Room[]     //many-to-many 
  participants        Participant[]  //defining opposite relation 
  @@map(name: "users") 
}
model Status {
  id    String      @default(cuid()) @id
  title String      @unique
  users User[]      // one to many
}
 model Avatar {
  id                  String      @default(cuid()) @id
  formattedUrl        String      
  cloudinaryPublicId  String      
  user                User?       @relation("UserAvatar")
}


model NoteWidget {
  id                  String       @default(cuid()) @id
  room                Room         @relation(fields: [room_fk], references: [id])
  room_fk             String       @unique
  noteItem            NoteItem[]
}

model NoteItem {
  id                String         @default(cuid()) @id
  title             String
  text              String
  created_at        DateTime        @default(now())
  updated_at        DateTime        @default(now())
  note_widget       NoteWidget      @relation(fields: [note_widget_fk], references: [id])
  note_widget_fk    String         
}

